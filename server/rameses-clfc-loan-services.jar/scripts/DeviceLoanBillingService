import com.rameses.common.*;
import com.rameses.annotations.*;

class DeviceLoanBillingService
{
	@ActiveDB(value="loan_route")
	def route;

	@ActiveDB(value="loan_ledger")
	def ledger;

	@ActiveDB(value="batch_payment")
	def batch_payment;

	@ActiveDB(value="loan_product_type")
	def product_type;

	@ActiveDB(value="loan_ledger_billing")
	def ledger_billing;

	@Service('DateService')
	def dateSvc;

	@Service('SequenceService') 
	def seqSvc;

	@Service("LoanLedgerService")
	def ledgerSvc;

	@ProxyMethod
	public def getRoutes(params) {
		def result = route.getList();
		def list = [];
		list.addAll(result)
		return list;
	}


	@ProxyMethod
	public def downloadBilling(params) {
		if (!params.route_code) throw new Exception('Please specify route code');
		if (!params.billingid) throw new Exception('Please specify billingid');

		if (ledger_billing.findBillingLock([billingid: params.billingid, routecode: params.route_code])) 
			throw new Exception('This billing has already been downloaded.');

		def unpostedpayment = batch_payment.findUnpostedPayment(params);
		if (unpostedpayment) throw new Exception('Cannot download billing. There are still unposted payments.');

		def result = ledger_billing.getBillingDetailByRoutecode(params);
		if (!result) throw new Exception('No billing for route '+params.route_description+' - '+params.route_area);


		def noNexttoList = result.findAll{ it.nextto == null }
		def hasNexttoList = result.findAll{ it.nextto != null }

		for(int i=0; i<hasNexttoList.size(); i++) {
			for(int j=i+1; j<hasNexttoList.size(); j++) {
				if (hasNexttoList[i].nextto == hasNexttoList[j].acctid) {
					hasNexttoList.add(i, hasNexttoList.remove(j));
					i=0;
					break;
				}
			}
		}

		def list = [];
		noNexttoList.each{ list.add(it); }
		def map;
		hasNexttoList.each{itm->
			map = noNexttoList.find{ it.acctid == itm.nextto }
			if (map) {
				list.remove(map);
				list.add(map);
			}
			list.add(itm);
		}
		list.eachWithIndex{itm, idx->
			itm.seqno = idx+1;
		}
		//result.each{ list.add(it); }
		ledger_billing.create([billingid: params.billingid, routecode: params.route_code], "lock");
		return [list: list];
	}

	@ProxyMethod
	public def uploadPayments( params ) {
		if (!params.sessionid) throw new Exception('Session ID is required.');
		if (!params.payments) throw new Exception('Payments are required.');
		createBatchPaymentHeader(params);

		def data = batch_payment.read([objid: params.sessionid]);
		def list = [];
		params.payments.each{
			def itm = batch_payment.read([objid: it.detailid], 'detail');//batch_payment.findDetailByAppIdAndParentId([appid: it.loanappid, parentid: data.objid]);
			if (!itm) {
				itm = [
					objid: 		it.detailid,//'BPDTL'+new java.rmi.server.UID(),
					parentid: 	data.objid,
					refno: 		it.refno,
					appid: 		it.loanappid,
					paytype: 	it.paytype,
					payamount: 	it.payamount
				]
				batch_payment.create(itm, "detail");
			}
			list.add(it.loanappid); 
		}
		return [list: list];
	}

	private void createBatchPaymentHeader( params ) {
		def itm = batch_payment.read([objid: params.sessionid]);
		if (!itm) {
			def txndate = dateSvc.parse("yyyy-mm-dd", params.txndate);
			itm = [
				objid: 			params.sessionid,
				state: 			'DRAFT',
				dtcreated: 		dateSvc.serverDate,
				txndate: 		txndate,
				route_code: 	params.routecode,
				totalcount: 	params.totalcount,
				totalamount: 	params.totalamount
			];
			batch_payment.create(itm);
		}
	}
}