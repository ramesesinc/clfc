import com.rameses.common.*;
import com.rameses.annotations.*;

class DeviceLoanBillingService
{
	@ActiveDB(value="loan_route")
	def route;

	@ActiveDB(value="loan_ledger")
	def ledger;

	@ActiveDB(value="batch_collectionsheet")
	def batch_collectionsheet;

	@ActiveDB(value="loan_product_type")
	def product_type;

	@ActiveDB(value="loan_ledger_billing")
	def ledger_billing;

	@ActiveDB(value="user")
	def user;

	@Service('DateService')
	def dateSvc;

	@Service('SequenceService') 
	def seqSvc;

	@Service("LoanLedgerService")
	def ledgerSvc;

	@ProxyMethod
	public def getRoutes(params) {
		def result = route.getList();
		def list = [];
		list.addAll(result)
		return list;
	}


	@ProxyMethod
	public def downloadBilling(params) {
		if (!params.route_code) throw new Exception('Please specify route code');
		if (!params.billingid) throw new Exception('Please specify billingid');

		if (ledger_billing.findBillingLock([billingid: params.billingid, routecode: params.route_code])) 
			throw new Exception('This billing has already been downloaded.');

		def unpostedpayment = batch_collectionsheet.findUnpostedPayment(params);
		if (unpostedpayment) throw new Exception('Cannot download billing. There are still unposted payments.');

		def result = ledger_billing.getBillingDetailByRoutecode(params);
		if (!result) throw new Exception('No billing for route '+params.route_description+' - '+params.route_area);


		def noNexttoList = result.findAll{ it.nextto == null }
		def hasNexttoList = result.findAll{ it.nextto != null }

		for(int i=0; i<hasNexttoList.size(); i++) {
			for(int j=i+1; j<hasNexttoList.size(); j++) {
				if (hasNexttoList[i].nextto == hasNexttoList[j].acctid) {
					hasNexttoList.add(i, hasNexttoList.remove(j));
					i = 0;
					break;
				}
			}
		}

		def list = [];
		noNexttoList.each{ list.add(it); }
		def map;
		hasNexttoList.each{itm->
			map = noNexttoList.find{ it.acctid == itm.nextto }
			if (map) {
				list.remove(map);
				list.add(map);
			}
			list.add(itm);
		}
		def payments;
		def notes;
		list.reverse().eachWithIndex{itm, idx->
			itm.seqno = idx+1;
			payments = batch_collectionsheet.getPaymentsByDetailid([parentid: itm.objid]);
			itm.payments = [];
			payments.each{
				it.detailid = itm.objid;
				it.loanappid = itm.loanappid;
				it.amount = it.payamount;
				it.type = it.paytype;
				it.routecode = itm.route.code;
				it.isfirstbill = itm.isfirstbill;
				it.txndate = itm.txndate;
				itm.payments.add(it);
			}
			notes = batch_collectionsheet.getNotesByDetailid([parentid: itm.objid]);
			itm.notes = [];
			notes.each{
				it.loanappid = itm.loanappid;
				itm.notes.add(it);
			}
			map = batch_collectionsheet.findDetailById([objid: itm.objid]);
			if (map && map.remarks) itm.remarks = map.remarks;
			else itm.remove("remarks");
		}
		ledger_billing.create([billingid: params.billingid, routecode: params.route_code], "lock");
		return [list: list];
	}

	@ProxyMethod
	public def uploadCollectionSheets( params ) {
		if (!params.sessionid) throw new Exception('Session ID is required.');
		if (!params.collectionsheet) throw new Exception('Collection Sheet is required.');
		createBatchCollectionSheetHeader(params);
		createBatchCollectionSheetDetail(params);

		def collectionsheet = params.collectionsheet;
		def data = batch_collectionsheet.read([objid: params.sessionid]);
		def itm;
		def list = [];
		collectionsheet.payments.each{
			itm = batch_collectionsheet.read(it, "payment");
			if (!itm) {
				itm = [:];
				itm.putAll(it);
				itm.parentid = collectionsheet.detailid;
				batch_collectionsheet.create(itm, "payment");
			}
			list.add(it.objid);
		}
		collectionsheet.notes.each{
			itm = batch_collectionsheet.read(it, "note");
			if (!itm) {
				itm = [:];
				itm.putAll(it);
				itm.parentid = collectionsheet.detailid;
				batch_collectionsheet.create(itm, "note");
			}
			list.add(it.objid);
		}
		//println 'list = '+list;
		def total = batch_collectionsheet.findTotalDetailByParentId([parentid: params.sessionid]).total;
		if (data.totalcount == total) {
			//throw new Exception('stopping');
			ledger_billing.changeStateUploaded([objid: params.sessionid]);
		}
		return [list: list];
	}

	@ProxyMethod
	public void createBatchCollectionSheetHeader( params ) {
		def itm = batch_collectionsheet.read([objid: params.sessionid]);
		if (!itm) {
			def date = dateSvc.serverDate;
			def txndate = dateSvc.parse("yyyy-MM-dd", params.txndate);
			def collector = user.read([objid: params.collectorid]);
			if (!collector) throw new Exception("Collector record does not exist or has already been deleted.");

			itm = [
				objid: 			params.sessionid,
				state: 			'DRAFT',
				dtposted: 		date,
				postedby: 		collector.name,
				dtcreated: 		date,
				txndate: 		txndate,
				route_code: 	params.routecode,
				totalcount: 	params.totalcount,
				totalamount: 	params.totalamount
			];
			batch_collectionsheet.create(itm);
		}
	}

	@ProxyMethod
	public void createBatchCollectionSheetDetail( params ) {
		def itm = batch_collectionsheet.read([objid: params.collectionsheet.detailid], "detail");
		if (!itm) {
			String remarks = params.collectionsheet.remarks? params.collectionsheet.remarks : "";
			itm = [
				objid: params.collectionsheet.detailid,
				parentid: params.sessionid,
				appid: params.collectionsheet.loanappid,
				remarks: remarks
			];
			batch_collectionsheet.create(itm, "detail");
		}
	}
}