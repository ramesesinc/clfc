import com.rameses.common.*;
import com.rameses.annotations.*;
import com.rameses.services.extended.*;
import java.rmi.server.UID;

class LoanLedgerBillingService extends ActiveCrudListService
{
	@Env
	def env;

	@ActiveDB(value="loan_ledger_billing")
	def em;

	@ActiveDB(value="loan_ledger")
	def loan_ledger;

	@ActiveDB(value="loan_product_type")
	def product_type;

	@Service("DateService")
	def dateSvc;

	@Service("SequenceService")
	def seqSvc;

	@ProxyMethod
	public def getColumns( params ) {
		return [
			[name:'collector.username', caption:'Collector'],
			[name:'billdate', caption:'Billing Date'],
			[name:'createdby', caption:'Created By'],
			[name:'dtmodified', caption:'Date Modified']
		]
	}

	void beforeList( data ) {
		data.searchtext = data.searchtext? data.searchtext+'%' : '%';
	}

	void beforeCreate( data ) {
		def currentDate = dateSvc.serverDate.toString().split(" ")[0];
		if (data.billdate.compareTo(currentDate) < 0) throw new Exception('Bill date should be greater than or equal to current date.');
		def o = em.findBillingByBilldate(data);
		if (o) throw new Exception('Billing for '+data.billdate+' has already been created.');

		data.createdby = env.USER;
		data.dtcreated = dateSvc.serverDate;
		data.dtmodified = data.dtcreated;
		data.collector.username = data.collector.name;
	}

	void afterCreate( data ) {
		updateRoute(data);
		updateBillingDetail(data);
	}

	void afterUpdate( data ) {
		updateRoute(data);
		updateBillingDetail(data);
	}

	void updateBillingDetail( data ) {
		em.removeBillingDetailByParentid([parentid: data.objid]);
		data.routes.each{o->
			def list = loan_ledger.getCollectionsheets([route_code: o.code]);
			def days = 0;
			list.each{
				def currentDate = dateSvc.serverDate;
				def detail = [
					objid: 'LLBD'+new UID(),
					parentid: data.objid,
					ledgerid: it.objid,
					route_code: o.code,
					acctid: it.loanappid,
					acctname: it.acctname,
					loanamount: it.loanamount,
					appno: it.appno,
					overpaymentamount: it.overpaymentamount,
					txndate: currentDate,
					dailydue: it.dailydue,
					dtmatured: it.dtmatured,
					producttypeid: it.producttypeid
				];
				detail.refno = 'B'+seqSvc.getNextFormattedSeriesA('loanbill', 8);
				def dtlastpaid;
				if (!it.dtlastpaid)
					dtlastpaid = dateSvc.add(it.dtstarted, "-1");
				else 
					dtlastpaid = dateSvc.parseDate(it.dtlastpaid, null).date;
				days = dateSvc.getDaysDiff(dtlastpaid, currentDate)-1;
				detail.amountdue = it.dailydue*days;
				detail.penalty = it.absentpenalty*(days-1);				
				detail.balance = getBalance(detail, it.balance);
				em.create(detail, "detail");
			}
		}
	}

	private def getBalance( params, balance ) {
		def bal = balance? balance : 0.00;
		if (balance == params.loanamount) {
			def producttype = product_type.read([name: params.producttypeid]);
			bal = params.loanamount*(producttype.term/100);
			params.isfirstbill = 1;
		} else {
			def ledgeritem = loan_ledger.findLastLedgerItemByParentId([parentid: params.ledgerid]);
			if (ledgeritem.interestbal > 0) bal += ledgeritem.interestbal;
			if (ledgeritem.penaltybal > 0) bal += ledgeritem.penaltybal;
			if (params.penalty > 0) bal += params.penalty;
			params.isfirstbill = 0;
		}
		bal = new BigDecimal(bal+'').setScale(2);
		return bal;
	}

	void updateRoute( data ) {
		em.removeRouteByBillingid([billingid: data.objid]);
		data.routes.each{o->
			def item = [
				billingid: data.objid,
				routecode: o.code
			];
			em.create(item, 'billing_route');
		}
	}

	void afterOpen( data ) {
		data.collector.name = data.collector.username;
		data.routes = em.getRoutesByBillingid([billingid: data.objid]);		
	}

	@ProxyMethod
	public def resetBilling( params ) {
		params.dtmodified = dateSvc.serverDate;
		em.update(params, "datemodified");
		updateBillingDetail(params);
		em.removeBillingLockByBillingid([billingid: params.objid])
	}
}