import com.rameses.common.*;
import com.rameses.annotations.*;
import com.rameses.services.extended.*;
import java.rmi.server.UID;

class LoanLedgerBillingService extends ActiveCrudService
{
	@Env
	def env;

	@ActiveDB(value="loan_ledger_billing")
	def em;

	@ActiveDB(value="loan_ledger")
	def loan_ledger;

	@ActiveDB(value="loan_product_type")
	def product_type;

	@ActiveDB(value="loan_exemption")
	def exemption;

	@Service("DateService")
	def dateSvc;

	@Service("SequenceService")
	def seqSvc;

	@Service("HolidayEventCalendarService")
	def calendarSvc;

	@Service("LoanLedgerService")
	def ledgerSvc;

	@ProxyMethod
	public def getNodes( params) {
		return [
			[caption: 'DRAFT', state: 'DRAFT'], 
			[caption: 'CANCELLED', state: 'CANCELLED'], 
			[caption: 'COMPLETED', state: 'COMPLETED'],
			[caption: 'UPLOADED', state: 'UPLOADED']
		];
	}

	@ProxyMethod
	public def getColumns( params ) {
		return [
			[name:'collector.username', caption:'Collector'],
			[name:'billdate', caption:'Billing Date'],
			[name:'createdby', caption:'Created By'],
			[name:'dtmodified', caption:'Date Modified']
		]
	}

	@ProxyMethod
	public def getList( params ) {
		params.searchtext = params.searchtext? params.searchtext+'%' : '%';
		def list = params.state? em.getList(params) : em.getDefaultList(params);
		list.each{ it.filetype = 'ledgerbilling' }
		return list;
	}

	/*void beforeList( data ) {
		data.searchtext = data.searchtext? data.searchtext+'%' : '%';
	}*/

	void beforeCreate( data ) {
		def currentDate = dateSvc.serverDate.toString().split(" ")[0];
		if (data.billdate.compareTo(currentDate) < 0) throw new Exception('Bill date should be greater than or equal to current date.');
		def o = em.findBillingByBilldate([collectorid: data.collector.objid, billdate: data.billdate]);
		if (o) throw new Exception('Billing '+data.billdate+' for collector '+data.collector.name+' has already been created.');

		data.createdby = env.USER;
		data.dtcreated = dateSvc.serverDate;
		data.dtmodified = data.dtcreated;
		data.collector.username = data.collector.name;
	}

	void afterCreate( data ) {
		updateRoute(data);
		updateBillingDetail(data);
	}

	void afterUpdate( data ) {
		updateRoute(data);
		updateBillingDetail(data);
	}

	void updateBillingDetail( data ) {
		em.removeBillingDetailByParentid([parentid: data.objid]);
		data.routes.each{o->
			def list = loan_ledger.getCollectionsheets([route_code: o.code]);
			def days = 0;
			list.each{
				def currentDate = dateSvc.parseDate(data.billdate, null).date;
				def maturityDate = dateSvc.parseDate(it.dtmatured, null).date;
				if (currentDate >  maturityDate && it.overduepenalty == 0.00) {
					def p = product_type.read([name: it.producttypeid])
					it.overduepenalty = ledgerSvc.computeOverduePenalty([balance: it.balance, pastduerate: (p.pastduerate? p.pastduerate : 0.00)]);
					loan_ledger.update(it, 'overduepenalty');
				}
				def detail = [
					objid: 'LLBD'+new UID(),
					parentid: data.objid,
					ledgerid: it.objid,
					route_code: o.code,
					acctid: it.acctid,
					loanappid: it.loanappid,
					acctname: it.acctname,
					loanamount: it.loanamount,
					loandate: it.loandate,
					term: it.term,
					appno: it.appno,
					overpaymentamount: it.overpaymentamount,
					txndate: currentDate,
					dailydue: it.dailydue,
					dtmatured: it.dtmatured,
					producttypeid: it.producttypeid,
					paymentmethod: it.paymentmethod,
					interestamount: it.interestamount,
					homeaddress: it.homeaddress,
					collectionaddress: it.collectionaddress? it.collectionaddress : '',
					interest: 0.00,
					others: 0.00,
					overduepenalty: it.overduepenalty
				];
				detail.refno = 'B'+seqSvc.getNextFormattedSeriesA('loanbill-'+o.code, 8);
				/*def dtschedule;
				if (!it.dtlastpaid)
					dtlastpaid = dateSvc.add(it.dtstarted, "-1");
				else 
					dtlastpaid = dateSvc.parseDate(it.dtlastpaid, null).date;*/
				def amt = it.dailydue;
				if (it.paymentmethod == 'over' && it.overpaymentamount > 0) amt = it.overpaymentamount; 
				detail.amountdue = (amt*days)+detail.others;
				days = dateSvc.getDaysDiff(it.dtcurrentschedule, currentDate);
				if (currentDate > maturityDate) {
					detail.penalty = days*it.overduepenalty;
					def amountdue = new BigDecimal((detail.penalty+(days*detail.interestamount)+it.balance)+'').setScale(0, BigDecimal.ROUND_CEILING);
					detail.amountdue = new BigDecimal(amountdue+'').setScale(2);
					detail.days = days;
				} else {
					def noofholidays = calendarSvc.getNoOfHolidays([lastscheduledate: it.dtcurrentschedule, item:[trialAndError: 0, totalDays: days]])
					days -= noofholidays;
					def cal = Calendar.getInstance();
					cal.setTime(currentDate);
					if ((cal.get(cal.DAY_OF_WEEK)-1) == 1) days--;
					days -= exemption.getExemptionsByStartdateAndEnddateAndLedgerid([startdate: it.dtcurrentschedule, enddate: currentDate, ledgerid: it.objid]).size();				
					detail.penalty = it.absentpenalty*(days > 0? days-1 : 0);
					detail.amountdue += detail.penalty;
				}
				detail.balance = getBalance(detail, it.balance);
				em.create(detail, "detail");
			}
		}
	}

	private def getBalance( params, balance ) {
		def bal = balance? balance : 0.00;
		if (balance == params.loanamount) {
			def producttype = product_type.read([name: params.producttypeid]);
			bal = params.loanamount*(producttype.term/100);
			params.isfirstbill = 1;
		} else {
			def ledgeritem = loan_ledger.findLastLedgerItemByParentId([parentid: params.ledgerid]);
			if (params.overduepenalty > 0) {
				bal += params.days*params.interestamount;
			} else {
				def avgamount = params.dailydue;
				if (params.paymentmethod == 'over') avgamount = em.findAvgOverpaymentAmount([parentid: params.ledgerid]).groupbaseamount;
				BigDecimal b = new BigDecimal(avgamount+'').setScale(2);
				b = b.subtract(new BigDecimal(params.interestamount+'').setScale(2));
				BigDecimal bd = new BigDecimal(balance+'').setScale(2)
				bd = bd.divide(b, BigDecimal.ROUND_HALF_UP);
				bal += (bd.setScale(0, BigDecimal.ROUND_HALF_UP)*params.interestamount);
			}
			
			if (ledgeritem.interestbal > 0) {
				params.amountdue += ledgeritem.interestbal;
				bal += ledgeritem.interestbal;
				params.interest += ledgeritem.interestbal;
			}
			if (ledgeritem.penaltybal > 0) {
				params.amountdue += ledgeritem.penaltybal;
				bal += ledgeritem.penaltybal;
				params.penalty += ledgeritem.penaltybal;
			}
			params.isfirstbill = 0;
		}
		if (params.penalty > 0) bal += params.penalty;
		bal = new BigDecimal(bal+'').setScale(0, BigDecimal.ROUND_CEILING);
		bal = new BigDecimal(bal+'').setScale(2);
		return bal;
	}

	void updateRoute( data ) {
		em.removeRouteByBillingid([billingid: data.objid]);
		data.routes.each{o->
			def item = [
				billingid: data.objid,
				routecode: o.code
			];
			em.create(item, 'billing_route');
		}
	}

	void afterOpen( data ) {
		data.collector.name = data.collector.username;
		data.routes = em.getRoutesByBillingid([billingid: data.objid]);		
	}

	@ProxyMethod
	public def resetBilling( params ) {
		params.dtmodified = dateSvc.serverDate;
		em.update(params, "datemodified");
		updateBillingDetail(params);
		em.removeBillingLockByBillingid([billingid: params.objid])
	}
}